# gbcloud
Данный проект представляет собой клиент-серверное облачное хранилище файлов, упрощенный аналог
DropBox. 

### Организация клиент-серверного взаимодействия.
Связь между клиентской и серверной частями приложения осуществляется по протоколу TCP/IP, на 
программном уровне используются сокетные библиотеки (Netty/java.nio), выбор осуществлется при сборке программы с помощью аннотаций. Разработан протокол клиент-серверного взаимодействия, отвечающий требованиям
к функциональности конечной программы. Через сокетные соединения  пересылаются сериализованные 
POJO-объекты, реализующие сообщения этого протокола. Используется стандартный бинарный сериализатор 
Java для пересылки объектов через канал java.nio и  ObjectEncoder / ObjectDecoder при использовании Netty. Весь обмен данными и командами между одним клиентом и сервером идет через одно сокетное
соединение. При этом на стороне сервера и клиента данное соединение может быть использовано из нескольких
потоков.

### Передача файлов.
Данные файлов передаются через то же сокетное соединение, что и команды, будучи упакованы в 
POJO-объекты протокола. На уровне протокола нет принципиального разделения на командные
сообщения и сообщения, содержащие данные файлов. Протокол построен по схеме "запрос-ответ", что 
позволяет осуществлять мультиплексирование нескольких "транзакций" через одно сокетное соединение. 
Например, пользователь сможет одновременно передавать на сервер большой файл, разбитый на несколько 
частей, и выполнять команды манипуляции с файлами на сервере (удалить, переместить и т.д.). То есть
передача большого файла, занимающая много времени, не "подвесит" соединение. Приведем пример обмена 
сообщениями между клиентом и сервером, который происходит в случае, если пользователь собирается
отправить в облако некоторый файл. Данный пример не является окончательным тех. решением, а призван 
продемонстрировать основную идею.
1. Клиент отправляет на сервер сообщение, инициирующее передачу файла. В этом сообщении содержится 
полный путь к файлу и его размер.
2. Сервер подтверждает готовность принимать данные, возвращая клиенту идентификатор "транзакции".
3. Клиент отправляет серию сообщений, содержащих данные файла. Эти сообщения помечаются полученным 
ранее от сервера идентификатором. Каждое сообщение содержит размер передаваемой части файла и сами 
данные в виде `byte[]`.
4. Транзакция завершается, когда сервер получит все данные файла. 

При этом в промежутки между описанными выше сообщениями могут "вклиниться" сообщения других 
"транзакций", например, пользователь может передавать несколько файлов параллельно как на
upload, так и на download.

### База данных.
Серверная часть программы будет использовать СУБД MySQL для хранения служебной информации. 
Для организации взаимодействия с БД используется JPA в реализации Hibernate. В базе данных будет
храниться информация о пользователях системы и их файлах. 

### Клиентский front-end.
В данном курсе предлагается оформить клиентскую часть в виде GUI-приложения на основе библиотек 
JavaFX или Swing. Запланированная функциональность системы скорее всего не оставит времени на 
разработку красивого GUI, поэтому предлагается альтернативный вариант. Клиентское приложение будет
представлять собой консольную программу, работающую в двух режимах - режиме ftp-образной оболочки с командами put, get и т.д. и в режиме отслеживания событий файловой системы. Во втором варианте пользователь будет 
взаимодействовать не напрямую с программой, а со своей файловой системой посредством того или 
иного файлового менеджера или shell-команд (mv, rm, cp и т.д.). При этом все производимые изменения зеркалируются в облако, поддерживая локальную и удаленную копию хранилища в синхронизированном состоянии.