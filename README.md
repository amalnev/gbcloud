# gbcloud
Данный проект представляет собой клиент-серверное облачное хранилище файлов, упрощенный аналог
DropBox. 

### Организация клиент-серверного взаимодействия.
Связь между клиентской и серверной частями приложения будет осуществляться по протоколу TCP/IP, на 
программном уровне будут использоваться сокетные библиотеки (Netty на стороне сервера, Netty + java.io
на стороне клиента). Будет разработан протокол клиент-серверного взаимодействия, отвечающий требованиям
к функциональности конечной программы. Через сокетные соединения будут пересылаться сериализованные 
POJO-объекты, реализующие сообщения этого протокола. Будет использоваться стандартный бинарный сериализатор 
Java. Весь обмен данными и командами между одним клиентом и сервером будет идти через одно сокетное
соединение. При этом на стороне сервера и клиента данное соединение может быть использовано из нескольких
потоков.

### Передача файлов.
Данные файлов будут передаваться через то же сокетное соединение, что и команды, будучи упакованы в 
POJO-объекты протокола. На уровне протокола не будет принципиального разделения на командные
сообщения и сообщения, содержащие данные файлов. Протокол будет построен по схеме "запрос-ответ", что 
позволит осуществлять мультиплексирование нескольких "транзакций" через одно сокетное соединение. 
Например, пользователь сможет одновременно передавать на сервер большой файл, разбитый на несколько 
частей, и выполнять команды манипуляции с файлами на сервере (удалить, переместить и т.д.). То есть
передача большого файла, занимающая много времени, не "подвесит" соединение. Приведем пример обмена 
сообщениями между клиентом и сервером, который происходит в случае, если пользователь собирается
отправить в облако некоторый файл. Данный пример не является окончательным тех. решением, а призван 
продемонстрировать основную идею.
1. Клиент отправляет на сервер сообщение, инициирующее передачу файла. В этом сообщении содержится 
полный путь к файлу и его размер.
2. Сервер подтверждает готовность принимать данные, возвращая клиенту идентификатор "транзакции".
3. Клиент отправляет серию сообщений, содержащих данные файла. Эти сообщения помечаются полученным 
ранее от сервера идентификатором. Каждое сообщение содержит размер передаваемой части файла и сами 
данные в виде `byte[]`.
4. Транзакция завершается, когда сервер получит все данные файла. 

При этом в промежутки между описанными выше сообщениями могут "вклиниться" сообщения других 
"транзакций", например, пользователь может передавать несколько файлов параллельно как на
upload, так и на download.

### База данных.
Серверная часть программы будет использовать СУБД MySQL для хранения служебной информации. 
Для организации взаимодействия с БД будет использоваться библиотека org.mybatis. В базе данных будет
храниться информация о пользователях системы и их файлах. Локальное хранилище на стороне клиента 
будет представлять собой отдельную директорию файловой системы с вложенной структурой дочерних 
директорий. Хранение файлов на стороне сервера предполагается в виде "плоского" репозитория, в 
котором все файлы всех пользователей лежат в одной общей директории. Структура вложенности на стороне
сервера будет храниться в БД. Также в БД будет содержаться информация о правах собственности и доступа
пользователей к тому или иному файлу или директории. Также база данных будет отвечать за флаги
блокировки того или иного файла. Например, в данный момент осуществляется скачивание некоторого файла
пользователем. В этот же момент этот или другой пользователь пытается данный файл переместить или удалить.
Такая ситуация должна быть корректно обработана.

### Клиентский front-end.
В данном курсе предлагается оформить клиентскую часть в виде GUI-приложения на основе библиотек 
JavaFX или Swing. Запланированная функциональность системы скорее всего не оставит времени на 
разработку красивого GUI, поэтому предлагается альтернативный вариант. Клиентское приложение будет
представлять собой консольную программу, вообще никак не взаимодействующую с пользователем. Вместо
этого данная программа при запуске будет синхронизировать локальное хранилище с сервером, после чего
начнет мониторить события файловой системы, относящиеся к директории локального хранилища. 
Соответствующие изменения будут сразу отправляться на сервер. Таким образом, пользователь будет 
взаимодействовать не напрямую с программой, а со своей файловой системой посредством того или 
иного файлового менеджера или shell-команд (mv, rm, cp и т.д.).  