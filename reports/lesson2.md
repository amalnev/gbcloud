## Отчет по домашнему заданию к уроку №2.

### Выполненные работы

1. Создан каркас maven-проекта, состоящего из 3-х модулей:
    1. gbcloud-server - серверная программа.
    2. gbcloud-client - клиентская программа.
    3. gbcloud-common - библиотека общих классов, использующихся как на стороне сервера, так и 
    на стороне клиента
    
2. Проработана и реализована в коде основа протокола клиент-серверного взаимодействия 
(см. поянения далее). 

3. Проработана и реализована общая архитектура программы (см. пояснения далее). 
Дальнейшая работа над проектом будет заключаться в добавлении новой функциональности в данную
архитектуру. 

4. Реализован сервер и клиент на основе Java NIO сокетов.

5. Реализована минимальная часть протокола клиент-серверного взаимодействия в виде обмена 
эхо-сообщениями по типу ICMP. 

6. Добавлено логгирование событий на стороне сервера и клиента. 

### Протокол. 

Клиент и сервер обмениваются сообщениями в виде сериализованых POJO-объектов. Все сообщения, 
пересылаемые между клиентом и сервером существуют в рамках так называемых *диалогов* 
(conversation). Диалог имеет уникальный идентификатор и каждое сообщение помечается 
идентификатором диалога, к которому оно относится. Конечными точками диалога являются *агенты*.
Например, при передаче файла с клиента на сервер на стороне клиента создается агент, который
вычитывает данные с диска, упаковывает их в сообщения и передает агенту-"собеседнику" на
стороне сервера. Этот серверный агент принмает входящие сообщения, распаковыает данные файла
и записывает их на диск на сервере. Благодаря тому, что каждое сообщение помечается 
идентификатором диалога, несколько пар агентов могут использовать одно сокетное соединение
для взаимодействия. 

Рассмотрим пример клиент-серверного взаимодействия в рамках данного протокола для простейшего
случая - обмена эхо-сообщениями:
1. На стороне клиента создается эхо-агент, который получает уникальный идентификатор диалога.
2. Клиентский эхо-агент формирует объект сообщения и посылает его на сервер через существующее
сокетное соединение.
3. Сервер считывает объект сообщения из сокета и понимает, что диалог, к которому относится
сообщение, ему неизвестен.
4. Сервер принимает решение, нужно ли участвовать в данном диалоге или нет. 
5. Если нет - 
отсылает сообщение об отказе, причем в этом сообщении идентификатор диалога устанавливается в
такое же значение, как и в исходном сообщении от клиента. Это позволяет клиентскому эхо-агенту
понять, что данный отказ адресован именно ему. 
6. Если сервер принимает решение поддержать диалог, то создается серверный эхо-агент, который
будет отвечать на тот же идентификатор диалога. Этому новому агенту передается сообщение от 
клиента.
7. Серверный эхо-агент выполняет два действия - отсылает клиенту эхо-ответ и закрывается, 
убирая соответствующий идентификатор диалога из списка активных диалогов, известных серверу.
8. Клиентский агент принимает эхо-ответ, выводит сообщение в консоль и завершает диалог.   
9. Если клиентский агент не успевает получить эхо-ответ за определенное время, то он закрывается
по таймауту, выведя соответствующее собщение в консоль.

### Соображения по архитектуре проекта.
 При проектировании архитектуры проекта предлагается использовать возможности CDI, включив
 контейнер WELD для SE-окружения. В частности, основная логика программы (диалоги и агенты)
 развязывается с транспортной логикой (сокетный сервер и клиент) через CDI-события. 
 Это позволит легко заменить текущую реализацию на основе java.nio на любую другую (Netty,
 java.io и т.д.). Более того, можно держать в рамках программы несколько реализаций и выбирать
 нужную с помощью, например, аннотаций:
 
 ```
 public class App
 {
    @Netty
    @Inject
    private ICloudServer server;
    
    public run()
    {
        ...
        server.start();
    }
``` 
Также при реализации асинхронной клиент-серверной программы большое значение имеет логгирование
событий. В нашем случае можно будет убрать весь логгирующий код в отдельные классы с помощью
CDI-перехвата. Таким образом, основной код программы не будет засорен многочисленными
обращениями к логгеру. 