## Соображения по функциональности облачного хранилища.

На данном курсе предлагается разработать GUI front-end облачного хранилища с использованием 
библиотек JavaFX или Swing. Данное приложение позволило бы пользователю вручную выбирать файлы
с локальной файловой системы для загрузки в облако и для скачивания из облака на локальную 
файловую систему. В данном случае фактически задача сводится к разработке FTP-подобного протокола 
и реализации его клиентской и серверной части. Тем не менне, "ручное" перемещение файлов между
облаком и устройствами не вполне отвечает функциональности современных облачных систем хранения
данных. Гораздо ближе к продуктовому решению было бы 
приложение, позволяющее пользователю синхронизировать некоторую избранную директорию локальной 
файловой системы с облаком в автоматическом режиме, как это делает например "Яндес-диск". Однако
реализация такой системы в полном объеме представляет большую сложность и вряд ли может быть 
выполнена за отведенное время. Принципиальная сложность такого подхода заключается в возможных
конфликтах при синхронизации файловых систем с различных устройств пользователя, при том, что 
наше приложение не может иметь полного контроля над локальной файловой системой и соответственно
не может запретить пользователю выполнять над своей локальной файловой системой действия, 
конфликтующие с состоянием облака и действиями других пользователей (или того же пользователя с
другого устройства). Кроме того, есть проблема изменения локальной файловой системы при 
выключенном приложении и/или потере связи с облаком, когда локальные операции не зеркалируются
в облако. В этом случае при перезапуске приложения или восстановлении связи локальное и облачное
состояние окажутся рассинхронизированы, потребуется восстановление синхронизированного сотояния,
что представляет собой также неочевидную задачу. 
    
В результате предлагается разбить работу над проектом облачного хранилища на несколько этапов, каждый из которых будет добавлять в проект некоторый новый уровень функциональности. 
0. Синхронизация в ручном режиме, нулевой этап. На первом этапе будет разработано консольное приложение, позволяющее пользователю выполнять команды манипуляции с локальной и облачной фаловой системой, напоминающее ftp shell. Будут поддерживаться следующие команды:
    0. **open** - открыть соединение с облаком.
    1. **(l/r)pwd** - показать текущую локальную / удаленную директорию
    2. **(l/r)cd** - перейти в другую локальную / удаленную директорию
    3. **(l/r)ls** - вывести листинг локальной / удаленной директории
    4. **(l/r)mkdir** - создать новую директорию локально / удаленно
    5. **put** - отправить локальный файл в облако
    6. **get** - скачать файл из облака на локальную файловую систему.
    7. **close** - закрыть соединение с облаком.
    8. **help** - вывести помощь по командам.
    9. **exit** - выйти из программы
    10. **ping** - проверить соединение при помощи эхо-сообщения

1. Автоматическая синхронизация, первый этап. На данном этапе будет добавлен мониторинг событий локальной файловой системы и их зеркалирование в облако.
2. Автоматическая синхронизация, второй этап. На стороне облака будет добавлено зеркалирование событий файловой системы в сторону других устройств того же пользователя, одновременно подключенных к облаку.
3. Автоматическая синхронизация, третий этап. Будет добавлено журналирование событий файловой системы на стороне облака. В момент подключения клиентское устройство будет получать от облака журнал событий, произошедших в облаке за время, прошедшее с момента последнего подключения данного устройства. Таким образом можно будет решить проблему с рассинхронизацией локального и облачного хранилища при разрыве связи или выключении устройства.

Обязательным требованием к проекту предлагается считать реализацию нулевого этапа (ручной режим работы). Работа над следующими этапами будет вестись при наличии времени.

## Текущее состояние проекта.
В настоящий момент (перед первым code review) реализована часть нулевого этапа, а именно следующие команды: **open**, **close**, **help**, **exit**, **lpwd**, **rpwd**, **lcd**, **rcd**, **lls**, **rls**, **ping**.

## Code guide.
Небольшие пояснения по организации кода проекта, для облегчения review.
Общая архитектура проекта была описана в отчете ко второму практическому заданию (*reports/lesson2.md*). Вкратце картина такова:
1. Проект состоит из трех модулей **gbcloud-client**, **gbcloud-server**, **gbcloud-common**. Клиент и сервер - исполняемые модули (содержат pvsm), common - библиотека общих классов.
2. Клиент и сервер обмениваются сообщениями в виде сериализованных POJO. Соответствующие классы находятся в пакете **ru.malnev.gbcloud.common.messages**. Используется стандартный сериализатор Java. Каждое сообщение принадлежит к определенному *диалогу* (аналог http session). Клиент и сервер могут вести одновременно несколько диалогов через одно сокетное соединение. Конечными точками диалога являются *агенты* (аналог микросервисов). Каждое сообщение содержит идентификатор диалога, к которому относится, эта информация позволяет маршрутизировать входящие сообщения тому агенту, который их ожидает.
3. Классы клиентских агентов находятся в пакете **...client.conversations**, серверных - в пакете **...server.conversations**. Агенты представляют собой небольшие классы, большая часть логики работы которых описывается аннотациями. Основная часть логики, связанной с активацией агентов, управлением их временем жизни и маршрутизацией сообщений находится в пакете **...common.conversations**, а конкретно в классах **AbstractConversation** и **AbstractConversationManager**.
4. Код, касающийся организации сетевого взаимодействия с помощью библиотек **java.nio** и **Netty** находится в пакетах **transport** (client.transport, common.transport, server.transport). Реализованы два варианта сервера и два варианта клиента. Кокретная реализация выбирается с помощью CDI-аннотаций **@Nio** и **@Netty** в точке внедрения.
5. "Транспортная" часть и логика агентов и их диалогов развязаны с помощью CDI событий. Классы событий и их обработчики находятся в пакетах **events** и **handlers**, которые присутствуют на клиенте, сервере и в common.
6. Логгирование организовано с помощью CDI-перехвата, что позволяет собрать все логгирование в одном месте. Пакеты **logging** на клиенте, сервере и в common-части.
7. Пакеты **config** на клиенте, сервере и common-части - это модуль программных настроек, разрабатывавшийся в проекте сетевого чата. Позволяет читать и синхронизировать глобальные настройки программы такие как адрес сервера, TCP-порт, логин и т.д. между тремя источниками - командной строкой, Preferences API и hard-coded дефолтами.
8. На стороне клиента реализован простой CLI. Соответствующие классы находятся в пакете **client.commands**. Классы консольных команд, как и классы агентов - это легковесные бины, большая часть поведения которых декларируется при помощи аннотаций, а не определяется в Java-коде. Код же находится в основном в классах **AbstractCommand** и **CommandParser**.
9. База данных MySQL в настоящее время используется на стороне сервера для хранения пользователей. Работа с базой организована через Hibernate. Пакет **server.persistence**.